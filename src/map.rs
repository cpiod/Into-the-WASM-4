use crate::wasm4::*;
use crate::*;

// atlas
pub const ATLAS_WIDTH: u32 = 48;
pub const ATLAS_FLAGS: u32 = 1; // BLIT_2BPP
pub const ATLAS: [u8; 312] = [ 0xaa,0xaa,0xa9,0xaa,0xaa,0xa9,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xa4,0xaa,0xaa,0xa4,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0x90,0xaa,0xaa,0x90,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xa9,0x40,0xaa,0xa9,0x40,0xaa,0xaa,0xa9,0x6a,0xaa,0xaa,0xaa,0xa4,0x00,0xaa,0xa4,0x00,0xaa,0xaa,0xa5,0x6a,0xaa,0xaa,0xaa,0x90,0x00,0xaa,0x90,0x00,0xaa,0xaa,0x94,0x56,0xaa,0xaa,0xa9,0x40,0x00,0xa9,0x40,0x00,0xaa,0xaa,0x51,0x05,0xaa,0xaa,0xa4,0x00,0x00,0xa4,0x00,0x00,0xaa,0xaa,0x41,0x01,0xaa,0xaa,0x90,0x00,0x00,0x90,0x00,0x00,0xaa,0xa9,0x40,0x41,0x6a,0xaa,0x40,0x00,0x00,0x40,0x00,0x00,0xaa,0xa5,0x00,0x10,0x6a,0xaa,0x50,0x00,0x00,0x50,0x00,0x00,0xaa,0x94,0x00,0x00,0x6a,0xaa,0x44,0x00,0x00,0x44,0x00,0x00,0xaa,0x50,0x00,0x00,0x5a,0xaa,0x41,0x40,0x00,0x41,0x40,0x00,0xaa,0x40,0x10,0x40,0x16,0xaa,0x40,0x10,0x00,0x90,0x10,0x00,0xa9,0x40,0x10,0x10,0x05,0x6a,0x40,0x04,0x00,0xa4,0x04,0x00,0xa5,0x00,0x40,0x10,0x00,0x5a,0x40,0x01,0x40,0xa9,0x41,0x40,0x94,0x01,0x00,0x14,0x00,0x16,0x40,0x00,0x10,0xaa,0x90,0x10,0x50,0x01,0x00,0x11,0x00,0x05,0x90,0x00,0x04,0xaa,0xa4,0x04,0x90,0x04,0x00,0x11,0x00,0x06,0xa4,0x00,0x01,0xaa,0xa9,0x41,0xa4,0x00,0x00,0x10,0x50,0x1a,0xa9,0x40,0x01,0xaa,0xaa,0x91,0xa9,0x40,0x00,0x40,0x01,0x6a,0xaa,0x90,0x01,0xaa,0xaa,0xa5,0xaa,0x90,0x00,0x40,0x06,0xaa,0xaa,0xa4,0x01,0xaa,0xaa,0xa9,0xaa,0xa4,0x00,0x00,0x1a,0xaa,0xaa,0xa9,0x41,0xaa,0xaa,0xaa,0xaa,0xa9,0x40,0x01,0x6a,0xaa,0xaa,0xaa,0x91,0xaa,0xaa,0xaa,0xaa,0xaa,0x90,0x06,0xaa,0xaa,0xaa,0xaa,0xa5,0xaa,0xaa,0xaa,0xaa,0xaa,0xa4,0x1a,0xaa,0xaa,0xaa,0xaa,0xa9,0xaa,0xaa,0xaa,0xaa,0xaa,0xa9,0x6a,0xaa,0xaa ];

#[derive(Clone, Copy)]
enum TileType {
    Dirt,
    Water,
    Mountain,
    City,
    NoTile
}

const MAP: [[[TileType; 6]; 6]; 1] =
  [[[TileType::Mountain,TileType::Mountain, TileType::Dirt,     TileType::Dirt,     TileType::Dirt,     TileType::Mountain],
    [TileType::Dirt,    TileType::Mountain, TileType::Dirt,     TileType::Dirt,     TileType::Dirt,     TileType::Water],
    [TileType::Dirt,    TileType::Dirt,     TileType::Dirt,     TileType::Dirt,     TileType::Dirt,     TileType::Water],
    [TileType::Mountain,TileType::Dirt,     TileType::Dirt,     TileType::Dirt,     TileType::Dirt,     TileType::Water],
    [TileType::Dirt,    TileType::Dirt,     TileType::Dirt,     TileType::Dirt,     TileType::Water,    TileType::Water],
    [TileType::Dirt,    TileType::Dirt,     TileType::Water,    TileType::Water,    TileType::Water,    TileType::Water]]];

pub struct Map {
    map: [[TileType; 6]; 6],
}

impl Default for Map {
    fn default() -> Self {
        Map::new(0)
    }
}

impl Map {
    pub fn new(id: usize) -> Self {
        Map { map : MAP[id] }
    }

    pub unsafe fn render(&mut self) {
        *DRAW_COLORS = 0x0021;
        for sum in -5i32..=5 {
            for x in 0i32..6 {
                let y=sum+x;
                if y>=0 && y<6 {
                    let (sx, mut sy) = board_to_screen(x as u8,y as u8);
                    let n = self.map[y as usize][x as usize];
                    match n {
                        TileType::Water => {
                            sy+=4;
                            blit_sub(&ATLAS, sx, sy, 12, 22, 12, 0, ATLAS_WIDTH, ATLAS_FLAGS);
                            blit_sub(&ATLAS, sx+12, sy, 12, 22, 12, 0, ATLAS_WIDTH, ATLAS_FLAGS | BLIT_FLIP_X);
                        },
                        _ => {
                            blit_sub(&ATLAS, sx, sy, 12, 26, 0, 0, ATLAS_WIDTH, ATLAS_FLAGS);
                            blit_sub(&ATLAS, sx+12, sy, 12, 26, 0, 0, ATLAS_WIDTH, ATLAS_FLAGS | BLIT_FLIP_X);
                        }
                    }
                    if matches!(n,TileType::Mountain) { // mountain
                        blit_sub(&ATLAS, sx, sy-4, 24, 19, 24, 3, ATLAS_WIDTH, ATLAS_FLAGS);
                    }
                }
            }
        }
    }
}
